# new和malloc的区别

## new与malloc的10点区别

## 1. 申请的内存所在位置

new操作符从**自由存储区（free store）**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

特别的，new甚至可以不为对象分配内存！**定位new**的功能可以办到这一点：

```cpp
new (place_address) type
```

place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：

```cpp
void * operator new (size_t,void *) //不允许重定义这个版本的operator new
```

这个operator new**不分配任何的内存**，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。

## 2.返回类型安全性

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全**性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。

## 3.内存分配失败时的返回值

new内存分配失败时，会抛出bac_alloc异常，它**不会返回NULL**；malloc分配内存失败时返回NULL。
在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：

```cpp
int *a  = (int *)malloc ( sizeof (int ));
if(NULL == a)
{
    ...
}
else 
{
    ...
}
```

从C语言走入C++阵营的新手可能会把这个习惯带入C++：

```cpp
int * a = new int();
if(NULL == a)
{
    ...
}
else
{   
    ...
}
```

实际上这样做**一点意义也没有**，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：

```cpp
try
{
    int *a = new int();
}
catch (bad_alloc)
{
    ...
}
```

如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。

## 4.是否需要指定内存大小

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

```cpp
class A{...}
A * ptr = new A;
A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 
```

当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。

## 5.是否调用构造函数/析构函数

使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，**原始**的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：

```cpp
class A
{
public:
	A() :a(1), b(1.11){}
private:
	int a;
	double b;
};
int main()
{
	A * ptr = (A*)malloc(sizeof(A));
	return 0;
}
```

在return处设置断点，观看ptr所指内存的内容：
![img](https://images2015.cnblogs.com/blog/610439/201601/610439-20160119004300406-962244228.png)

可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。

而使用new来分配对象时：

```cpp
int main()
{
    A * ptr = new A;
}
```

查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：

![img](https://images2015.cnblogs.com/blog/610439/201601/610439-20160119004332328-1197338727.png)

## 6.对数组的处理

C++提供了new[]与delete[]来专门处理数组类型:

```cpp
	A * ptr = new A[10];//分配10个A对象
```

使用new[]分配的内存必须使用delete[]进行释放：

```cpp
    delete [] ptr;
```

new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

```cpp
int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组
```

## 7.new与malloc是否可以相互调用

operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：

```cpp
void * operator new (sieze_t size)
{
    if(void * mem = malloc(size)
        return mem;
    else
        throw bad_alloc();
}
void operator delete(void *mem) noexcept
{
    free(mem);
}
```

## 8.是否可以被重载

opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：

```cpp
//这些版本可能抛出异常
void * operator new(size_t);
void * operator new[](size_t);
void * operator delete (void * )noexcept;
void * operator delete[](void *0）noexcept;
//这些版本承诺不抛出异常
void * operator new(size_t ,nothrow_t&) noexcept;
void * operator new[](size_t, nothrow_t& );
void * operator delete (void *,nothrow_t& )noexcept;
void * operator delete[](void *0,nothrow_t& ）noexcept;
```

我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。

而malloc/free并**不允许重载**。

## 9. 能够直观地重新分配内存

使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

new没有这样直观的配套设施来扩充内存。

## 10. 客户处理内存分配不足

在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是**new-handler**。new_handler是一个指针类型：

```cpp
namespace std
{
    typedef void (*new_handler)();
}
```

指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:

```cpp
namespace std
{
    new_handler set_new_handler(new_handler p ) throw();
}
```

set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。

对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

# 总结

将上面所述的10点差别整理成表格：

|         特征         |              new/delete               |             malloc/free              |
| :------------------: | :-----------------------------------: | :----------------------------------: |
|    分配内存的位置    |              自由存储区               |                  堆                  |
| 内存分配成功的返回值 |             完整类型指针              |                void*                 |
| 内存分配失败的返回值 |             默认抛出异常              |               返回NULL               |
|    分配内存的大小    |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|       处理数组       |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|   已分配内存的扩充   |            无法直观地处理             |         使用realloc简单完成          |
|     是否相互调用     | 可以，看具体的operator new/delete实现 |             不可调用new              |
|  分配内存时内存不足  | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|       函数重载       |                 允许                  |                不允许                |
|  构造函数与析构函数  |                 调用                  |                不调用                |

malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种

而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:

当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。









# # 操作系统中堆v.s.栈

**堆**：一般是在**堆**的头部用一个字节存放**堆**的大小。 **堆中**的具体内容有程序员安排。 **栈**：在函数调用时第一个进**栈**的是主函数**中**后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器**中**，参数是由右往左入**栈**，然后是函数**中**的局部变量。 注意: 静态变量是不入**栈**的。

# 一、程序的内存分配



对于一个由C/C++编译的程序，其所占用的内存可以划分为以下几个部分：



1. **栈区（stack）**—— 由操作系统自动分配和释放，主要用于存放函数参数值，局部变量等。其操作方式类似于数据结构中的栈。 
2. **堆区（heap）**—— 一般由程序员动态分配和释放，若程序员不主动释放，则程序结束后由操作系统回收。注意，它与数据结构中的堆是不同的，分配方式类似于链表。 
3. **BSS段**——主要用于存放未初始化的静态变量和全局变量，可读写，它在程序结束后由操作系统进行释放。
4. **数据段（data）**——主要用于存放已初始化的静态变量和全局变量，可读写，它在程序结束后由操作系统释放。
5. **代码段（text）**——主要用于保存程序代码，包括CPU执行的机器指令，同时全局常量也是保存在代码段的，如字符串字面值。

# 二、程序实例

```plain
/main.cpp
int a = 0;                       // 全局初始化区域
char *p1;                        // 全局未初始化区域
int main(){
    int b;                       // 栈
    char s[] = "adoryn";         // 栈
    char *p2;                    // 栈
    char *p3 = "zhaobryant";     // 字符串字面量存放在常量区，p3存放在栈上
    static int c = 0;            // 全局（静态）初始化区域
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);     // 分配获得的10和20字节的内存区放在堆区
    strcpy(p1, "zhaobryant");    // 字符串字面量存放在常量区，编译器可能会将它与p3所指向的"zhaobryant"优化为同一个地址
    return 0;
}
```

# 三、堆和栈的理论知识

## 1. 申请方式对比

**栈stack：**

由系统自动分配。例如，声明在函数中一个局部变量，即*int b*，系统自动在栈中为变量b开辟空间。

**堆heap：**



需要程序员自己申请，并指明大小。

在C中使用malloc函数，如*p1 = (char \*)malloc(10)*

在C++中用new运算符，如*p2 = new char[10]*

但是p1、p2本身是在栈中的。

## 2. 申请后系统响应



**栈stack：**

只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将返回异常提示栈溢出。

**堆heap：**

首先应该知道操作系统有一个记录空闲内存块节点的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的内存块节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放内存空间。另外，由于找到的空闲内存块节点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

## 3. 申请大小的限制



**栈stack：**

在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。也就是说，栈顶的地址和栈的最大容量是系统预先规定好的。在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示内存溢出。因此，能从栈获得的空间较小。

**堆heap：**

堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

## 4. 申请效率对比

栈由系统自动分配，速度较快，但程序员是无法控制的。

堆是由new/malloc进行内存分配，一般速度比较慢，且容易产生内存碎片，不过用起来最方便，速度快，也最灵活。

## 5. 存储内容对比



**栈stack：**

在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地 址，也就是主函数中的下一条指令，程序由该点继续运行。

**堆heap：**

一般是在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。

## 6. 存取效率对比



对比两段代码：

*char s1[] = "aaaaaaaaaaaaaaa";*

*char \*s2 = "bbbbbbbbbbbbbbbbb";* 

如上，aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的。

但是，在以后的存取中，在栈上的数组比指针所指向的字符串快。

例如：

```cpp
#include ...
int main(){
    char a = 1;
    char c[] = "1234567890";
    char *p = "1234567890";
    a = c[1];
    a = p[1];
    return 0;
}
```

对应的汇编代码：

```cpp
10: a = c[1];
00401067 8A 4D F1 mov c1, byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4], c1
11: a = p[1];
0040106D 8B 55 EC mov edx, dword ptr [ebp-14h]
0040106D 8A 42 01 mov a1, byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4], a1 
```

第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。

## 7. 小结



堆和栈的区别可以用如下的比喻来看出：



- 使用栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，其好处是快捷简单，但是自由度小。
- 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。